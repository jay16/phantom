require "./base.rb"

@shapes_without_oriention, @shapes_hash = [], {}
@shapes_with_oriention = @shapes_with_oriention.uniq
  .map { |arr| original_shape(arr) }.uniq


_shapes = []
@shapes_with_oriention.each do |shape|
  next if _shapes.include?(shape)
  @shapes_without_oriention.push(shape)
  uid = shape_chain(shape).join
  shapes_with_oriention = turnover_oriention(shape)
  @shapes_hash[uid] = shapes_with_oriention
  _shapes += shapes_with_oriention
end

#puts @shapes_without_oriention.count
#@shapes_without_oriention.each do |shape|
#  print_array(shape)
#end

exit
_shapes = []
_all_orientions_shapes = []
_container.uniq.each do |shape|
  if not _all_orientions_shapes.include?(shape)
    _shapes.push(shape) 
    turnover_oriention(shape).each do |_shape|
      _all_orientions_shapes.push(original_shape(_shape))
    end
  end
end
#_shapes.each do |shape|
#  print_array(shape)
#end
puts _shapes.count
exit
all_orientions = _all_orientions_shapes.uniq
puts all_orientions.count
@less_3_levels = all_orientions.find_all { |_array| _array.length <=3 }
puts @less_3_levels.count
#@less_3_levels.each do |shape|
#  print_array(shape)
#end

def whether_continue(board)
  is_continue = true
  (1..BW-1).each do |tag|
    if whether_closed(board, tag)
      if activate_points(board, tag).count < 5
        is_continue = false 
        break
      end
    end
  end
  return is_continue
end

def whether_closed(board, tag)
  is_closed = true
  for i in (0..BD-1)
    break unless is_closed
    for j in (0..BW-1)
      if i + j == tag
        if board[i][j] == 0
          is_closed = false 
          break
        end
      end
    end
  end
  return is_closed
end
def activate_points(board, tag)
  points = []
  for i in (0..BD-1)
    for j in (0..BW-1)
      if i + j <= tag
        points.push([i,j]) if board[i][j] == 0
      end
    end
  end
  return points
end


# 积木形状数据字链接
def shape_chain(shape)
  _chain, _i = [], 1
  shape.each do |row|
    row.each do |item|
      if item > 0
        _chain.push(_i)
        _i += 1
      end
    end
  end
  return _chain
end
# 按积木形状的宽度对board进行切割
# 查找匹配位置 - 自左向右
def whether_shape_adapte_board(board, shape)
  _depth = shape.length
  _width = shape.map { |row| row.find_all { |data| data > 0 }.length }.max
  _chain = shape_chain(shape)

  _d, _w = BD/_depth, BW/_width
  #puts shape.to_s
  #puts "[%d,%d] [%d,%d] " % [_d,_w,_depth,_width]
  _pos = []
  (0.._d-1).each do |d|
    break if not _pos.empty?
    (0.._w-1).each do |w|
      _board = Array.new(_depth){ Array.new(_width, 0) }
      for i in (0..BD-1)
        for j in (0..BW-1)
          if i >= d * _depth and i < d * _depth + _depth and
             j >= w * _width and j < w * _width + _width
             begin
             _board[i-d*_depth][j-w*_width] = board[i][j]
             rescue => e
               puts "[%d,%d]" % [i-d*_depth,j-w*_width]
               puts board[i][j]
               puts shape.to_s
               puts e.message
               exit
             end
          end # if
        end # for i
      end # for j

      chain = shape_chain(_board)
      if (_chain - chain).to_s == _chain.to_s
        _pos = [d, w]
        break
      end
    end
  end
  return _pos
end

def put_shape_to_board(board, shape, pos)
  _d, _w = pos
  _depth = shape.length 
  _d_base = _depth * _d
  _width = shape.map { |row| row.find_all { |data| data > 0 }.length }.max 
  _w_base = _width * _w
  
  for i in (0.._depth-1)
    for j in (0.._width-1)
      board[i+_d_base][j+_w_base] = 1 if shape[i][j] == 1
    end
  end
  return board
end

def check_successfully(board)
  num = board.map { |row| row.find_all { |item| item == 0 }.length }.reduce(:+)
  if num <= 10
    puts num
    print_array(board)
  end
  num == 0
end

def combine_bricks(board)
  _board = copy_array(board)
  @less_3_levels.each do |shape|
    if whether_continue(board)
      pos = whether_shape_adapte_board(board, shape)
      if not pos.empty?
        board = put_shape_to_board(board, shape, pos)
        if check_successfully(board)
          print_array(board)
        else
          combine_bricks(board)
        end
      end
      board = copy_array(_board)
    end
  end
end

board = Array.new(3){ Array.new(20, 0) }
combine_bricks(board)

=begin
array = Array.new(LEN){ Array.new(LEN, 0) }
array[0][0] = 1
array[0][1] = 1
array[0][2] = 1
array[1][0] = 1
array[1][1] = 1
print_array(array)
four_oriention(array).each do |shape|
  print_array(original_shape(shape))
end
=end
